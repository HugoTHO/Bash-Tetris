#include "../include/game.h"
#include "../include/rand.h"
#include <csignal>
#include <cstring>
#include <cstdio>
#include <pthread.h>
#include <unistd.h>
#define SPEED 500000
#define PENAL_SIZE (12*24*sizeof(int))
#define CUBE_SIZE (4*4*sizeof(int))

pthread_mutex_t	mutex_lock;

int num = 0;

//In order to call the srand function only once, the random number generated by this time is not repeated
static Rand r;

void Game::printNextCube(Context* graph)
{
	int x,y;
	int i,j;
	Cur c;
	CubePoint p;   

	c.saveCur();
	c.moveCur(6,19);
	cout<<"next : ";
	c.resumeCur();

	int a[4][4] = {0};  //Get an array of squares
	graph->getLocate(&x,&y);
	memcpy(a,graph->getArray(),CUBE_SIZE);
	for(i = 0; i < 4; i++)
		for(j = 0; j < 4; j++)
		{
			p.setLocate(i+7,j+19);
			p.setColor(CLEAR);
			p.printPoint();
			p.setLocate(i+6+x,j+19);
			if(a[i][j] == 1)
			{
				p.setColor(graph->getColor());
				p.printPoint();
			}
		}
}

void Game::printHelep()
{
	Cur c;
	c.saveCur();
	c.moveCur(12,19);
	cout<<"a: go to left" << endl;
	c.resumeCur();
	c.saveCur();
	c.moveCur(13,19);
	cout<<"d: go to right" << endl;
	c.resumeCur();
	c.saveCur();
	c.moveCur(14,19);
	cout<<"w: roll cube" << endl;
	c.resumeCur();
	c.saveCur();
	c.moveCur(15,19);
	cout<<"s: go to down" << endl;
	c.resumeCur();
	c.saveCur();
	c.moveCur(16,19);
	cout<<"p: run or pause" << endl;
	c.resumeCur();
}

void Game::gameInit()
{
	printHelep();

	nextGraph = new Context(getShape());
	nextGraph->draw();
	nextGraph->setLocate(1,7);

	createCube();
}

MARK Game::getMark()
{
	return mark;
}
void Game::setMark( MARK mark )
{
	this->mark = mark;
}

Game::~Game()
{
	if( NULL != m_graph )
	{
		delete m_graph;
		m_graph = NULL;
	}

	if( NULL != nextGraph )
	{
		delete nextGraph;
		nextGraph = NULL;
	}
}

Game::Game()
{
	m_graph = NULL;
	CubePoint p;
	int i;
	s.printMessage();

	mark = GAME_RUN;

	memset((void*)m_penal,0,PENAL_SIZE); 
	memset((void*)m_color,0,PENAL_SIZE);
	for(i = 0; i < 24; i++)
	{
		p.setLocate(i,5);
		p.setColor(BLUE);
		p.printPoint();
		p.setLocate(i,16);
		p.setColor(BLUE);
		p.printPoint();
		m_penal[i][0] = 1;
		m_penal[i][11] = 1;
	}
	for(i = 0; i < 12; i++)
	{
		p.setLocate(23,5+i);
		p.setColor(BLUE);
		p.printPoint();
		p.setLocate(0,5+i);
		p.setColor(RED);
		p.printPoint();
		m_penal[23][i] = 1;
		m_penal[0][i] = 1;
	}
	fflush(stdout);
}

char Game::getShape()
{
	char ch;
	switch(r.randNum(1,8))
	{
		case 1:ch = 'Z';break;
		case 2:ch = 'S';break;
		case 3:ch = 'T';break;
		case 4:ch = 'O';break;
		case 5:ch = 'I';break;
		case 6:ch = 'L';break;
		case 7:ch = 'J';break;
		default:
			   cout<<"no this shape type"<<endl;
			   ch = '\0';
			   break;
	}
	return ch;
}

bool Game::checkPanel()
{
	int x,y;
	int i,j;
	int b[4][4] = {0};  //Get an array of squares

	m_graph->getLocate(&x,&y);
	memcpy(b,m_graph->getArray(),CUBE_SIZE);
	for(i = 1; i < 4; i++)
		for(j = 1; j < 4; j++)
		{
			if(m_penal[i+x][j+y] + b[i][j] > 1)
			{
				Cur c;
				c.moveCur(11,6);
				cout<<"game over"<<endl;
				c.moveCur(23,0);
				//Plus score statistics rankings
				system("stty icanon echo");
				exit(0);
			}
		}
	return true;
}

void Game::increasePanel()
{
	int x,y;
	int i,j;
	int b[4][4] = {0};  //Get an array of squares

	m_graph->getLocate(&x,&y);
	memcpy(b,m_graph->getArray(),CUBE_SIZE);
	for(i = x; i < x + 4; i++)
		for(j = y; j < y + 4; j++)
		{
			m_penal[i][j] += b[i-x][j-y];
			if(b[i-x][j-y] == 1)
				m_color[i][j] = m_graph->getColor();
		}

	//Destroy block object and create newer one
	delete m_graph;
	m_graph = NULL;
	createCube();
}

void Game::createCube()
{
	m_graph = nextGraph;
	m_graph->printG(YELLOW);
	checkPanel();

	nextGraph = new Context(getShape());
	nextGraph->draw();
	nextGraph->setLocate(1,7);
	printNextCube(nextGraph);
}

void Game::move(int dir)
{

	if(GAME_RUN != mark)
		return;
	pthread_mutex_lock(&mutex_lock);
	switch(dir)
	{
		case DOWN:
			if(false == isAttachBottom())
			{
				//Erase the old space and print in the new position.
				m_graph->printG(CLEAR);
				m_graph->move(DOWN);
				m_graph->printG(YELLOW);
			}
			else
			{
				increasePanel();
				m_graph->printG(YELLOW);
				checkLines();
			}
			break;
		case LEFT:
			if(false == isAttachLeft())
			{
				//Erase the old space and print in the new position.
				m_graph->printG(CLEAR);
				m_graph->move(LEFT);
				m_graph->printG(YELLOW);
			}
			break;
		case RIGHT:
			if(false == isAttachRight())
			{
				//Erase the old space and print in the new position.
				m_graph->printG(CLEAR);
				m_graph->move(RIGHT);
				m_graph->printG(YELLOW);
			}
			break;
		default:
			break;
	}
	pthread_mutex_unlock(&mutex_lock);
}

void Game::roll()
{
	//Remove the value of the box, first put into an array
	int x,y;
	int i,j;
	int flag = 0;
	int b[4][4] = {0};  //Get an array of squares
	int temp[4][4] = {0};

	m_graph->getLocate(&x,&y);
	memcpy(b,m_graph->getArray(),CUBE_SIZE);
	//Erase the old shape.
	m_graph->printG(CLEAR);
	//Rotate the array
	if (b[3][1] == 1)
        temp[1][0] = temp[1][1] = temp[1][2] = temp[1][3] = 1;
    else if (b[1][3] == 1)
        temp[0][1] = temp[1][1] = temp[2][1] = temp[3][1] = 1;
    else
    {
        for(i = 0; i < 3; i++)
            for(j = 0; j < 3; j++)
            {
                temp[2-j][i] = b[i][j];
            }
    }
	//Determine if the rotation will coincide with the panel
	for(i = 0; i < 4; i++)
	{
		for(j = 0; j < 4; j++)
		{
			if (temp[i][j] == 1 && m_penal[x + i][y + j] == 1)   
			{
				flag = 1;
				break;
			}
		}
		if(flag == 1)
			break;
	}
	//If do not coincide, rotate the box and set the panel value
	if(flag == 0)
	{
		m_graph->roll();
	}
	m_graph->printG(YELLOW);

}
void Game::fall()
{
	if(GAME_RUN != mark)
		return;
	while(false == isAttachBottom())
	{
		m_graph->printG(CLEAR);
		m_graph->move(DOWN);
		m_graph->printG(YELLOW);
	}
}

bool Game::isAttachBottom()
{
	int i,j;
	int cube_x,cube_y;
	int b[4][4] = {0};  //Get an array of squares
	int flag = false;

	m_graph->getLocate(&cube_x,&cube_y);
	memcpy(b,m_graph->getArray(),CUBE_SIZE);

	for(i = 0; i < 4; i++)
	{
		for(j = 0; j < 4; j++)
		{
		   if (b[i][j] == 1 && m_penal[i + cube_x + 1][j + cube_y] == 1)
		   {
				flag = true;
				break;
		   }
		}
		if (flag == true)
			break;
	}
	return flag;
}

bool Game::isAttachLeft()
{
	int i,j;
	int cube_x,cube_y;
	int b[4][4] = {0};  //Get an array of squares
	int flag = false;

	m_graph->getLocate(&cube_x,&cube_y);
	memcpy(b,m_graph->getArray(),CUBE_SIZE);

	for(i = 0; i < 4; i++)
	{
		for(j = 0; j < 4; j++)
		{
		   if (b[i][j] == 1 && m_penal[i + cube_x][j + cube_y - 1] == 1)
		   {
				flag = true;
				break;
		   }
		}
		if (flag == true)
			break;
	}
	return flag;

}

bool Game::isAttachRight()
{
	int i,j;
	int cube_x,cube_y;
	int b[4][4] = {0};  //Get an array of squares
	int flag = false;

	m_graph->getLocate(&cube_x,&cube_y);
	memcpy(b,m_graph->getArray(),CUBE_SIZE);

	for(i = 0; i < 4; i++)
	{
		for(j = 0; j < 4; j++)
		{
		   if (b[i][j] == 1 && m_penal[i + cube_x][j + cube_y + 1] == 1)
		   {
				flag = true;
				break;
		   }
		}
		if (flag == true)
			break;
	}
	return flag;
}

void Game::checkLines()
{
   int i,j;
   int flag = 0;
   static int count = 0;
   for(i = 22; i > 0; i--)
   {
		for(j = 1; j < 11; j++)
		{
			if(m_penal[i][j] == 0)
			{
				flag = 1;
			}
		}
		if(flag == 0)
		{
			//Add points!
			count++;
			s.setScore(count);
			s.printMessage();

			//The line above the overall picture is pulled
			downPanel(i);
			i++;
		}
		flag = 0;
   }
}

void Game::downPanel(int level)
{
	int i,j;
	int flag = 1;

	for(i = level; i > 1; i--)
		for(j = 1; j < 11; j++)
		{
			m_penal[i][j] = m_penal[i - 1][j];
			m_color[i][j] = m_color[i - 1][j];
		}
	//Refresh the panel
	CubePoint p;
	for(i = 1; i < 23; i++)
		for(j = 1; j < 11; j++)
		{
			if(m_penal[i][j] == 1)
			{
				p.setLocate(i,5+j);
				p.setColor(m_color[i][j]);
				p.printPoint();
			}
			if(m_penal[i][j] == 0)
			{
				p.setLocate(i,5+j);
				p.setColor(CLEAR);
				p.printPoint();
			}
		}
}

void* listenKey(void *ptr)
{
	Game* ptrg = (Game*)ptr;
	char key;
	while(1)
	{
		key = getchar();
		switch(key)
		{
			case 'a':
				ptrg->move(LEFT);break;
			case 'd':
				ptrg->move(RIGHT);break;
			case 'w':
				ptrg->roll();break;
			case 's':
				//Downhill
				ptrg->fall();break;
			case 'p':
				if(GAME_RUN == ptrg->getMark())
					ptrg->setMark(GAME_PAUSE);
				else 
					ptrg->setMark(GAME_RUN);
				break;
			default:
				break;
		}
	}
}

//Manipulate the "Ctrl+C" on terminal
void SignalHandlerFunction (int sig)
{
	system("stty icanon echo");
	system("clear");
	fflush(stdout);
	kill(getpid(), SIGKILL);
}

int main()
{
	signal(SIGINT, SignalHandlerFunction);
	pthread_t t1;
	pthread_mutex_init(&mutex_lock, NULL);
	system("clear");
	system("stty -icanon -echo");
	Game g;
	//g.createCube();
	g.gameInit();
	pthread_create(&t1,NULL,listenKey,(void*)(&g));

	while(1)
	{
		fflush(stdout);
		usleep(SPEED);
		g.move(DOWN);
	}
	return 0;
}
